var store = [{
        "title": "BOJ 1000. A+B",
        "excerpt":"문제 링크 : https://www.acmicpc.net/problem/1000   특이한 점   System.in.read() 사용   ascii code의 문자값으로 저장되므로 -‘0’을 해서 처리가 가능했다.  ","categories": ["알고리즘"],
        "tags": [],
        "url": "http://localhost:4000/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/Algorithm_00/",
        "teaser": null
      },{
        "title": "Java 빌드 경로 에러",
        "excerpt":"Eclipse 상에서 다음과 같은 메시지가 나타났을 때, 오류 처리 방법 -The project cannot be built until build path errors are resolved Java SE 9 환경에서 작성한 코드를 Java SE 8 환경에서 열어보려고 하니, build path가 달라 빌드를 진행하지 못하는 문제가 발생하였다. 프로젝트 우클릭 &gt; build path &gt; configure build path...","categories": ["Java"],
        "tags": [],
        "url": "http://localhost:4000/java/Java_00/",
        "teaser": null
      },{
        "title": "Github Pages 삽질기_01",
        "excerpt":"clone한 jekyll 프로젝트를 github에 push하여 페이지가 올라가는 것 까지는 확인했으나, jekyll serve를 이용한 로컬에서의 확인이 되지 않아 삽질을 하였다. 우선 jekyll 공식 홈페이지 MacOS install 가이드를 따라했다. 루비 버전을 체크했는데 2020년 버전이 아니라 2019년 버전에서 쎄함을 느낌… 뭔가 안 맞을 때는 재설치가 특효약인 경우가 많으므로 우선 재설치를 진행하였다. 다시 설치했는데도...","categories": ["Github","Pages"],
        "tags": [],
        "url": "http://localhost:4000/github/pages/Github_Page_00/",
        "teaser": null
      },{
        "title": "BOJ 4949. 균형잡힌 세상",
        "excerpt":"1. 문제 4949번: 균형잡힌 세상 소괄호 또는 대괄호의 짝을 찾아주는 문제. 2. 개념 및 기술 주요 개념 Stack 자료구조의 일종으로, Last In First Out의 성질을 띄고 있는 자료구조이다. 기타 요소 StringBuilder https://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html System.out.println을 통해 계속해서 출력하게 되면 성능 저하가 있을 수 있으므로, StringBuilder를 이용하여 한번에 출력하도록 하였다. String.toCharArray(); https://docs.oracle.com/javase/7/docs/api/java/lang/String.html 문자열을...","categories": ["알고리즘"],
        "tags": [],
        "url": "http://localhost:4000/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/Algorithm_00/",
        "teaser": null
      },{
        "title": "Today I Learned_220131",
        "excerpt":"Spring  인프런 자바 강의   UTF-8 필터 처리, @Service, @Repository, @Controller   Controller 객체 구현 - @RequestMapping을 이용한 url mapping. @RequestMapping 사용 방법   Request Parameter를 얻는 세 가지 방법           HttpServletRequest객체를 이용            @RequestParam annotaion 이용            커맨드 객체 이용       이클립스에서 다른 브라우저 띄우기   TIL 작성  https://doing7.tistory.com/4   Jekyll 디렉토리 구조  https://jekyllrb-ko.github.io/docs/structure/  ","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_220131/",
        "teaser": null
      },{
        "title": "Today I Learned_220201",
        "excerpt":"Spring 인프런 자바 강의 Controller 객체 커맨드 객체, @ModelAttribute를 이용해 view에서 참조하는 객체의 이름 변경, 중첩 커맨드 객체 Model &amp; ModelAndView 객체 Model : 뷰에 데이터만을 전달하기 위한 객체 ModelAndView : 데이터와 뷰의 이름을 함께 전달 Session &amp; Cookie Session, Cookie - 차이점, 사용 이유 Session : HttpServletRequest.getSession(), HttpSession setAttribute,...","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_220201/",
        "teaser": null
      },{
        "title": "Today I Learned_220206",
        "excerpt":"Spring 인프런 자바 강의 오류 Could not publish server configuration for Tomcat v8.5 Server at localhost. Multiple Contexts have a path of Publishing failed Publishing failed with multiple errors Error reading file 맥에서 오라클 jdbc 설정해 봤는데 안 됨. 이 방법도 안 되고 이 방법도 안 됨 Oracle 맥에서 oracle...","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_220206/",
        "teaser": null
      },{
        "title": "Today I Learned_220207",
        "excerpt":"JDBC   어제 해결하지 못했던 class not found 오류 해결. 참고링크   ojdbc6.jar 라이브러리 파일 경로와 프로젝트의 java 라이브러리 선택이 문제였다.     ","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_220207/",
        "teaser": null
      },{
        "title": "Today I Learned_220208",
        "excerpt":"Spring 인프런 자바 강의 JDBC Template Jdbc : Java를 이용해 데이터베이스와 통신하는 방법 Jdbc만을 사용하려면 드라이버 로딩 - DB 연결 - SQL 작성 - 자원 해제 이 모든 과정을 DAO객체에서 일일히 반복해야 함. 이러한 일련의 과정들을 한 번에 할 수 있게 한 것이 JDBC Template. 중복된 코드를 제거하고 DataSource에 저장하여...","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_220208/",
        "teaser": null
      },{
        "title": "Today I Learned_220215",
        "excerpt":"AWS Certified Developer Associate AWS Skill builder에서 강의 수강 : Exam Readiness: AWS Certified Developer – Associate (Digital) (Korean) CI/CD 지속적 통합, 지속적 전달, 지속적 배포의 개념 CI/CD에 사용하는 AWS 서비스 AWS CodeCommit : 관리형 소스 제어 서비스 AWS CodeBuild : 코드 컴파일 및 테스트 실행 AWS CodeDelpoy : 언어,...","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_220215/",
        "teaser": null
      },{
        "title": "Today I Learned_220216",
        "excerpt":"AWS Certified Developer Associate AWS Skill builder에서 강의 수강 : Exam Readiness: AWS Certified Developer – Associate (Digital) (Korean) AWS CloudFormation 코드형 인프라 관리 도구. 버전 관리를 통해 코드 관리 또한 가능 전체 애플리케이션 스택 및 애플리케이션의 리소스 정의 가능 공식 문서 AWS CloudFormation 템플릿의 구조 여러 섹션이 있지만 리소스...","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_220216/",
        "teaser": null
      },{
        "title": "Today I Learned_220222",
        "excerpt":"AWS Certified Developer Associate AWS Skill builder에서 강의 수강 : Exam Readiness: AWS Certified Developer – Associate (Digital) (Korean) AWS Identity and Access Management(IAM) IAM 사용자 AWS에 생성하는 엔터티. 이 엔터티를 사용하여 AWS와 상호 작용하는 사람 또는 서비스를 나타낸다. AWS에서 사용자는 이름과 자격 증명으로 구성됨 IAM 그룹 IAM 사용자의 모음...","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_220222/",
        "teaser": null
      },{
        "title": "Today I Learned_220307",
        "excerpt":"AWS Certified Developer Associate AWS Skill builder에서 강의 수강 : Exam Readiness: AWS Certified Developer – Associate (Digital) (Korean) Amazon S3 버킷 사용자가 생성하는 글로벌 네임스페이스의 일부 특정 리전에서 버킷 이름을 생성하는 경우 해당 이름은 전체 리전에서 고유하며 개별 리전에만 국한되지 않는다. 객체 버킷 내부에 저장하는 파일 또는 객체 데이터...","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_220307/",
        "teaser": null
      },{
        "title": "Today I Learned_220309",
        "excerpt":"AWS Certified Developer Associate AWS Skill builder에서 강의 수강 : Exam Readiness: AWS Certified Developer – Associate (Digital) (Korean) Amazon Simple Notification Service(SNS) 유연한 완전 관리형 게시/구독 알림 서비스 모바일 알림에도 사용되며 구독 엔드포인트 및 클라이언트에 메시지 전달을 조정하는데 사용된다. 분산 시스템, 서비스 모바일 디바이스 등 다수의 구독자들에게 메시지 전송...","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_220309/",
        "teaser": null
      },{
        "title": "Today I Learned_220329",
        "excerpt":"Spring Framework 인프런 스프링 강의 수강 스프링의 역사 EJB를 사용하고 있었음 : 이론적으로는 좋은 프레임워크였지만 비싸고 어렵고 복잡하고 느림 로드 존슨이 EJB를 대체한 단순한 개발 프레임워크 제시(EJB의 문제점 지적) -&gt; 스프링의 기원(J2EE Design and Development) 스프링은 설정, 세팅, 빌드가 어려운 프레임워크 -&gt; 2014년 스프링 부트가 출시됨으로써 스프링 설정을 쉽게 할...","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_220329/",
        "teaser": null
      },{
        "title": "Today I Learned_220404",
        "excerpt":"Spring Framework 인프런 스프링 강의 수강 객체 지향의 특징과 스프링 객체 지향의 특징 : 추상화, 캡슐화, 상속, 다형성 -&gt; 스프링에서는 다형성의 개념이 중요하다. 스프링 프레임워크는 어떻게 보면 다형성을 쉽게 구현할 수 있도록 지원하는 프레임워크. (제어의 역전, 의존관계 주입) 객체 지향 프로그래밍이란? 객체 지향 프로그래밍이란? 프로그램을 객체들의 모임으로 파악 각각의 객체는...","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_220404/",
        "teaser": null
      },{
        "title": "Today I Learned_220405",
        "excerpt":"DataBase  쿼리 결과값에 차례대로 순번 부여하는 방법 : ROWNUM 사용   DB 튜닝 / SQL튜닝하는 방법에는 무엇이 있는지 고민해 보자.   네트워크 및 인프라  L4 로드밸런싱 방법 : RR, Hash, Least-Connection   AP(무선 액세스 포인트) : 무선 장치들을 유선 장치에 연결할 수 있게 하는 장치  ","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_220405/",
        "teaser": null
      },{
        "title": "Today I Learned_220406",
        "excerpt":"Node.js 파일 시스템을 사용하기 위한 fs Node.js 동작 원리 Spring Framework 인프런 스프링 강의 수강 좋은 객체 지향 설계의 5가지 원칙(SOLID) SRP: 단일 책임 원칙(single responsibility principle) 한 클래스는 하나의 책임만 가져야 한다. 하나의 책임이라는 것은 모호하며, 문맥과 상황에 따라 다를 수 있다 책임의 기준은 변경. 변경이 있을 때 파급...","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_220406/",
        "teaser": null
      },{
        "title": "Today I Learned_220407",
        "excerpt":"Spring Framework 인프런 스프링 강의 수강 우아한 테코톡 : Spring vs. Spring Boot 객체 지향 설계와 스프링 스프링은 DI, DI 컨테이너를 통해 다형성, OCP, DIP를 가능하게 지원한다. -&gt; 클라이언트 코드의 변경 없이 기능 확장 OCP, DIP 원칙을 지키면서 개발을 하다보면 결국 스프링 컨테이너(DI 컨테이너)를 만들게 된다. 이상적으로는 모든 설계에 인터페이스를...","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_220407/",
        "teaser": null
      },{
        "title": "Today I Learned_220410",
        "excerpt":"Spring Framework 인프런 스프링 강의 수강 스프링 프로젝트 생성 스프링 부트를 이용한 스프링 프로젝트 생성 Dependency를 선택하지 않으면 스프링 부트가 코어쪽 라이브러리만 선택해서 가져온다 - 별도의 의존관계 설정하지 않음 initilizr -&gt; 다운 -&gt; 압축풀기 -&gt; intelliJ에서 build.gradle을 project로 오픈 gradle 수정 시 &gt; Gradle에서 Reload All gradle project를 통해 리로드를...","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_220410/",
        "teaser": null
      },{
        "title": "Today I Learned_220411",
        "excerpt":"Web 3계층 구조 MSA, monolithic Web Server vs. WAS Web Server vs. WAS Web 인터넷을 기반으로 한 정보를 공유, 검색할 수 있게 하는 서비스 주소, 통신규격, 내용으로 이루어짐 Server 클라이언트에게 네트워크를 통해 정보나 서비스를 제공하는 컴퓨터 시스템 Web Server 인터넷을 기반으로 클라이언트에게 웹 서비스를 제공하는 컴퓨터. 정적인 데이터로 한정되어 있다....","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_220411/",
        "teaser": null
      },{
        "title": "Today I Learned_220412",
        "excerpt":"git merge와 rebase의 차이 Merge branch를 통합하는 것 branch에 head가 추가되는 식 추가하던 기능이 완료되었을 때 merge 사용 Rebase branch의 base를 옮기는 것 특정 지점으로 base를 옮기고 기존에 있던 commit을 재정렬한다 git history를 깔끔하게 하기 위하여 사용 reset과 revert의 차이 Reset 시간을 아예 과거의 특정 commit으로 되돌린다. 현재까지의 commit 이력을...","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_220412/",
        "teaser": null
      },{
        "title": "Today I Learned_220413",
        "excerpt":"git  git 연결 끊기   git remote 저장소 설정   ","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_220413/",
        "teaser": null
      },{
        "title": "Today I Learned_220417",
        "excerpt":"Spring Framework 인프런 스프링 강의 수강 인터페이스 객체랑 구현 객체랑 다르게 두는 것이 설계상 좋다. 인터페이스 -&gt; 구현체 순으로 개발하자. IntelliJ 소스 창에서 command + N : 생성자 만드는 단축키 인터페이스 구현 후 구현되지 않은 함수들 자동 구현 : option + enter 문장 쓰다가 command + shift + enter :...","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_220417/",
        "teaser": null
      },{
        "title": "Today I Learned_220418",
        "excerpt":"Spring Framework 인프런 스프링 강의 수강 spring test에 있는 CoreApplicationTests : 스프링 기본 테스트. 잘 띄워지나 테스트한다. 단위 테스트를 만드는 것이 중요하다. 스프링이나 컨테이너 도움 없이 순수한 자바 코드로 테스트 하는 테스트 코드를 만드는 것이 중요하다. IntelliJ 오류가 났을 때 F2 -&gt; 오류가 난 곳으로 바로 이동 이 때 option...","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_220418/",
        "teaser": null
      },{
        "title": "Today I Learned_220420",
        "excerpt":"Spring Framework 인프런 스프링 강의 수강 애자일 소프트웨어 개발 선언 IntelliJ 함수 선택 후 command + shift + T : create new Test testing library : JUnit5 class name : 원래 클래스네임 뒤에 테스트를 붙여주는데 그대로 쓰면 된다. JUnit5 @Test @DisplayName(“이걸 사용하면 한글로 이름을 쓸 수가 있다.”) -&gt; @Test 밑에...","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_220420/",
        "teaser": null
      },{
        "title": "Today I Learned_220422",
        "excerpt":"Github Blog jekyll : Ruby 기반의 정적 사이트 생성기 블로그를 정돈해 보려면 블로그 파일 구조를 알아야 겠다고 생각해서 공식문서 공부(?) https://jekyllrb.com/docs/ jekyll blog 구조 머리말 파일의 맨 처음에 세 개의 대시문자로 감싼 YAML 코드 조각. 해당 페이지에 대한 변수를 설정하는 데 사용된다. _layouts 블로그에 동일한 레이아웃을 적용하기 위한 레이아웃들이 보관된...","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_220422/",
        "teaser": null
      },{
        "title": "Today I Learned_220425",
        "excerpt":"Spring Framework 인프런 스프링 강의 수강 IntelliJ command + option + M : 함수 추출 패키지에서 오른쪽 클릭 -&gt; diagram : 객체들간의 관계를 볼 수있다. 사슬 모양 클릭하면 dependency도 볼 수 있음 IoC(Inversion of Control) 제어의 역전 기존 프로그램 : 클라이언트 구현 객체/프로그래머가 스스로 필요한 서버 구현 객체를 생성-연결-실행함 제어의...","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_220425/",
        "teaser": null
      },{
        "title": "Today I Learned_220426",
        "excerpt":"Spring Framework 인프런 스프링 강의 수강 스프링 컨테이너 스프링 컨테이너는 BeanFactory, ApplicationContext로 구분됨. BeanFactory가 좀 더 상위의 개념이다. 컨테이너 : 사용하는 객체들을 담은 것 ApplicationContext 전체 애플리케이션의 문맥을 뜻하며, 스프링 컨테이너라 한다. 스프링 컨테이너가 객체를 생성하고 DI를 진행한다. ApplicationContext는 인터페이스 명으로, Annotaion, XML을 사용하여 컨테이너를 생성하는 구현체를 받아 사용한다. @Configuration이...","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_220426/",
        "teaser": null
      },{
        "title": "Today I Learned_220429",
        "excerpt":"Spring Framework 인프런 스프링 강의 수강 IntelliJ iter : 입력하면 for문이 자동으로 완성됨. command + D : 복사한 걸 아래에다가 그대로 붙여넣기. 메서드 안에서 control + R : 해당 메소드 실행 Bean 조회하기 ApplicationConfigApplicationContext는 ac로 축약 ac.getBeanDefinitionNames() : config에 있는(스프링 컨테이너에 등록된) 모든 빈의 이름을 조회 ac.getBean(beanDefinitionName) : 이름이 beanDefinitionName인...","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_220429/",
        "teaser": null
      },{
        "title": "Today I Learned_220501",
        "excerpt":"Spring Framework Bean Bean 스프링 컨테이너가 관리하는 자바 객체(ApplicationContext가 알고 있는 객체) 스프링 컨테이너에 의해 인스턴스화, 관리 , 생성된다. 빈 등록 방법 @Component(@Controller 어노테이션 내부에 Component 존재) 어노테이션 사용 → 컴포넌트 스캐닝 방식 @Bean 어노테이션 사용 → Configuration을 통한 직접 등록 방식 보통 싱글턴으로 존재 싱글턴 : 어떤 클래스가 최초...","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_220501/",
        "teaser": null
      },{
        "title": "Today I Learned_220705",
        "excerpt":"Spring Framework 인프런 스프링 강의 수강 Bean 빈 조회 시, 부모 타입으로 조회하면 자식 타입도 함께 조회된다. [예시] 상속 관계가 아래와 같을 때 @Configuration static class TestConfig{ //상위 타입으로 선언하는 이유 : 개발하거나 설계를 할 때 역할과 구현을 쪼개는 것이라고 보면 됨 //얘는 DiscountPolicy라고 판별 //다른데서도 의존성 주입하기 편함 @Bean...","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_220705/",
        "teaser": null
      },{
        "title": "Today I Learned_220706",
        "excerpt":"Spring Framework 인프런 스프링 강의 수강 BeanFactory BeanFactory를 직접 사용할 일은 거의 없으며, 주로 ApplicationContext를 사용한다. BeanFactory 스프링 컨테이너의 최상위 인터페이스이며, 스프링 빈을 관리하고 조회하는 역할을 한다. getBean()을 제공한다. ApplicationContext BeanFactory를 상속받은 인터페이스. 애플리케이션 개발 시 필요한 부가기능을 포함 MessageSource : 다국어 처리 EnvironmentCapable : 환경변수 처리 ApplicationEventPublisher : 애플리케이션...","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_220706/",
        "teaser": null
      },{
        "title": "Today I Learned_220710",
        "excerpt":"Spring Framework 인프런 스프링 강의 수강 BeanDefinition 스프링은 BeanDefinition이라는 메타 정보로 스프링의 설정 메타 정보를 추상화 한다. AnnotationConfigApplicationContext로 생성 beanDefinitionName = memberService beanDefinition = Root bean: class [null]; scope=; abstract=false; lazyInit=null; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=appConfig; factoryMethodName=memberService; initMethodName=null; destroyMethodName=(inferred); defined in hello.core.AppConfig GenericXmlApplicationContext로 생성 beanDefinitionName = memberRepository beanDefinition = Generic...","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_220710/",
        "teaser": null
      },{
        "title": "Today I Learned_220719",
        "excerpt":"Spring Framework 인프런 스프링 강의 수강 Singleton 방식의 주의점 Singleton 방식 : 여러 클라이언트가 하나의 같은 객체 인스턴스 공유 -&gt; 객체 설계 시 stateless하게 설계해야 한다. 특정 클라이언트에 의존적인 필드가 있으면 안 된다. 특정 클라이언트가 값을 바꾸게 두면 안 된다. 가급적이면 읽기만 가능하고, 값을 수정하면 안 된다. 필드 대신 가급적이면...","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_220719/",
        "teaser": null
      },{
        "title": "Today I Learned_220724",
        "excerpt":"Spring Framework 인프런 스프링 강의 수강 필터 includeFilters : 컴포넌트 스캔 대상을 추가로 지정 excludeFilters : 컴포넌트 스캔에서 제외할 대상을 지정 FilterType 옵션 ANNOTATION : 기본값 ASSIGNABLE_TYPE : 지정한 타입과 자식 타입을 인식해서 동작 그 외에도 ASPECT_J, REGEX, CUSTOM이 있지만 ANNOTATION만 주로 많이 사용됨 컴포넌트 스캔 중복 등록 Component Scan에...","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_220724/",
        "teaser": null
      },{
        "title": "Today I Learned_220725",
        "excerpt":"Spring Framework 인프런 스프링 강의 수강 Dependency Injection(의존관계 주입) 생성자 주입 수정자 주입(setter 주입) 필드 주입 일반 메서드 주입 생성자 주입 생성자를 통해 의존관계 주입 불변, 필수적인 의존관계에 사용한다. 생성자 호출 시점에 딱 한 번만 호출되는것이 보장된다. -&gt; 그 때 가서 세팅하고 다음에 세팅 못하도록 막을 수 있다. getter/setter 없이...","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_220725/",
        "teaser": null
      },{
        "title": "Today I Learned_220726",
        "excerpt":"Spring Framework 인프런 스프링 강의 수강 Dependency Injection(의존관계 주입) 생성자 주입, 수정자 주입, 필드 주입, 메소드 주입 등 여러 방법이 있지만, 가급적이면 생성자 주입을 선택하자. 생성자 주입을 선택해야 하는 이유 불변 생성자 주입은 객체를 생성할 때 딱 1번만 호출되어 이후에 호출되는 일이 없음 -&gt; 불변하게 설계 가능 수정자 주입의 경우...","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_220726/",
        "teaser": null
      },{
        "title": "Today I Learned_220801",
        "excerpt":"Spring Framework 인프런 스프링 강의 수강 자동 빈 등록 vs. 수동 빈 등록 자동 빈 등록 : autowired, component scan 수동 빈 등록 : @Bean, config file 웬만한 경우에는 자동 빈 등록을 사용하자 -&gt; 스프링 부트가 지원을 잘 해주고 있으며, 설정 정보가 커지면 관리가 어렵다. 그리고 자동 빈 등록으로도 OCP,...","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_220801/",
        "teaser": null
      },{
        "title": "Today I Learned_220803",
        "excerpt":"Spring Framework 인프런 스프링 강의 수강 Bean Lifecycle Callback 스프링이 생성된 후나 소멸되기 전에 bean 안의 메소드를 호출할 수 있는 기능 스프링은 의존관계 주입이 완료거나, 컨테이너가 종료될 때 콜백을 준다(기준 : setter/filed injection, singleton scope) Spring Bean Event Lifecycle 조건 : singleton scope, 생성자 주입 제외 스프링 컨테이너 생성 -&gt;...","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_220803/",
        "teaser": null
      },{
        "title": "Today I Learned_220808",
        "excerpt":"Spring Framework 인프런 스프링 강의 수강 Bean Lifecycle Callback 빈 생명주기 콜백 지원 방법 인터페이스(InitializingBean, DisposableBean) 설정 정보에 초기화, 종료 메소드 지정 @PostConstruct, @PreDestroy 인터페이스(InitializingBean, DisposableBean) 클래스에 InitializingBean, DisposableBean 인터페이스를 implement하여 사용 InitializingBean : afterPropertiesSet() 메소드 구현 필요 DisposableBean : destroy() 메소드 구현 필요 스프링 초창기(2003년)에 나온 방식으로, 아래와 같은...","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_220808/",
        "teaser": null
      },{
        "title": "Today I Learned_220811",
        "excerpt":"Spring Framework 인프런 스프링 강의 수강 스프링 빈 스코프 싱글톤 : 기본적으로 생성되는 스코프 프로토타입 : 스프링 컨테이너가 의존관계를 주입해주고 초기화 메소드를 불러서 클라이언트에 반환하는데 까지 관리하는 범위의 스코프 웹 관련 스코프 : 스프링 웹과 관련된 기능이 들어가야 쓸 수 있는 스코프 request : 고객의 요청이 들어올 때 생성되고 나갈때...","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_220811/",
        "teaser": null
      },{
        "title": "Today I Learned_220813",
        "excerpt":"Spring Framework 인프런 스프링 강의 수강 Provider 싱글톤 빈 안에 의존관계 주입을 통해 프로토타입 빈을 사용할 경우 싱글톤 빈은 주입 시점에 스프링 컨테이너에 프로토타입 빈 요청 스프링 컨테이너는 프로토타입 빈을 생성해 싱글톤 빈에게 넘김 다른 클라이언트가 싱글톤 빈 호출 - 동일한 싱글톤 빈 호출이 됨 싱글톤 빈이 가지고 있는 프로토타입...","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_220813/",
        "teaser": null
      },{
        "title": "Today I Learned_220816",
        "excerpt":"HTTP 인프런 HTTP 강의 수강 모든 것이 HTTP 기반으로 동작함. 앱/서버 통신, 서버/서버 통신도 HTTP 프로토콜 위에서 진행 웹 기술, 웹 프레임워크 -&gt; 모두 HTTP 기반으로 구현이 되어 있음 HTTP 전체 흐름 HTTP : TCP/IP, UDP 기반으로 동작하기에 인터넷 네트워크를 알아야 한다. 인터넷 네트워크 인터넷 통신 IP(Internet Protocol) : 복잡한...","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_220816/",
        "teaser": null
      },{
        "title": "Today I Learned_220822",
        "excerpt":"HTTP 인프런 HTTP 강의 수강 HTTP HTTP의 특징 클라이언트 서버 구조 무상태 프로토콜 비연결성 HTTP 메시지 사용 HTTP로 할 수 있는 것들 HTTP : HyperText Transfer Protocol 처음에는 하이퍼텍스트를 전송하기 위한 프로토콜로 시작 -&gt; 지금은 모든 것을 전송한다 HTML, TEXT, 이미지, 음성, 영상, 파일, JSON, XML 등등 서버간에 데이터를 주고...","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_220822/",
        "teaser": null
      },{
        "title": "Today I Learned_220829",
        "excerpt":"HTTP 인프런 HTTP 강의 수강 HTTP 메서드 HTTP API 설계 GET, POST PUT, PATCH, DELETE HTTP 메서드의 속성 HTTP API 설계 API URI 설계 리소스 식별 -&gt; 가장 중요함 행위 자체가 리소스가 될 수는 없다. 예시 : 회원 조회 기능 -&gt; 리소스는 회원을 조회하는 기능이 아니라 회원 그 자체 리소스를...","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_220829/",
        "teaser": null
      },{
        "title": "Today I Learned_220830",
        "excerpt":"HTTP 인프런 HTTP 강의 수강 HTTP 메서드 활용 개발할 때 HTTP 메서드가 어떻게 활용되는가? 클라이언트에서 서버로 데이터 전송 HTTP API 설계 예시 클라이언트에서 서버로 데이터 전송 데이터 전달 방식 쿼리 스트링을 통한 데이터 전송 GET에 많이 사용 주로 검색어, 게시판 리스트에 정렬 조건을 넣을 때 많이 사용 메시지 바디를 통한...","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_220830/",
        "teaser": null
      },{
        "title": "Today I Learned_220915",
        "excerpt":"HTTP 인프런 HTTP 강의 수강 HTTP API 설계 예시 설계할 때 어떤 식으로 URI를 설계하는지? GET/POST/PUT/DELETE를 어떻게 써야 하는지? POST/PUT의 주요 특징들 리소스를 식별하는 것(URI) - 리소스를 식별해야지 다른 것을 식별하면 안 된다. 리소스는 행위가 아닌 자원! 행위는 메소드를 사용하면 된다. 회원 관리 시스템 POST 기반 등록 -&gt; 컬렉션 회원...","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_220915/",
        "teaser": null
      },{
        "title": "Today I Learned_220919",
        "excerpt":"HTTP 인프런 HTTP 강의 수강 HTTP 상태코드 클라이언트가 보낸 요청의 처리 상태를 서버의 응답으로 알려주는 기능 요청이 잘 처리가 되었는지? 문제가 되었는지? - request가 아니라 response로 알려주는 기능 현존하는 상태코드가 아니라 미래에 새로운 상태코드가 생겨서 모르는 상태코드를 서버가 반환한다면? -&gt; 클라이언트는 상위 상태코드로 해석해서 처리. 미래에 새로운 상태 코드가 추가되어도...","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_220919/",
        "teaser": null
      },{
        "title": "Today I Learned_221114",
        "excerpt":"HTTP 인프런 HTTP 강의 수강 HTTP 일반 헤더 헤더 필드의 구성 필드이름 : 필드값 Host: www.google.com Contemt-Type:text/html;charset=UTF-8 필드 이름은 대소문자 구분이 온다. 스타트 라인 다음에 쭉 헤더들이 오고, 그 다음 메시지 바디 부분이 들어온다. HTTP 헤더의 용도 HTTP 전송에 필요한 모든 부가 정보 (스타트 라인 제외) 필요 시 임의의 헤더...","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_221114/",
        "teaser": null
      },{
        "title": "Today I Learned_221117",
        "excerpt":"HTTP 인프런 HTTP 강의 수강 HTTP 헤더 - 캐시와 조건부 요청 캐시 기본 동작 캐시가 없을 때? -&gt; 계속 네트워크를 통해서 데이터를 다운로드 받아야 한다. 캐시 적용 헤더에 cache-control -&gt; 캐시가 유효한 시간을 초 단위로 설정할 수 있다. 캐시 가능 시간 동안 네트워크를 사용하지 않아도 된다. 브라우저 캐시를 참조하여 사용한다....","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_221117/",
        "teaser": null
      },{
        "title": "Today I Learned_221219",
        "excerpt":"TypeScript 인프런 타입스크립트 강의 수강 타입스크립트를 왜 배워야 하느냐? - 자바스크립트보다 안정적. 안정적 - 에러가 덜 난다. 타입스크립트들은 실수들을 잡아줄 뿐, 자바스크립트의 에러를 완전히 커버하지는 않는다. Trade-off에 의해 자바스크립트보다 자유도가 많이 줄어들었지만, 대신 안정성이 높아진다. 또한 자바스크립트에서 타입스크립트로 전환하는게 어렵지는 않음 - 러닝커브가 낮다. 자바스크립트 - 명시적인 자료형이 없다. 타입스크립트는...","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_221219/",
        "teaser": null
      },{
        "title": "Today I Learned_221226",
        "excerpt":"TypeScript 인프런 타입스크립트 강의 수강 타입스크립트 프로젝트 세팅 node 설치 → tsc 실행을 위함 Editor 설치 → Editor 자체가 tsc —noEmit을 계속 쳐주고 있기에, 타입검사를 자동으로 진행해준다. npm init -y #package.json 파일이 생김. 이 폴더를 노드 프로젝트로 만들겠다. npm i typescript #typescript 설치 -&gt; tsc 사용 가능 #설치 완료 후...","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_221226/",
        "teaser": null
      },{
        "title": "Today I Learned_230116",
        "excerpt":"TypeScript 인프런 타입스크립트 강의 수강 타입스크립트 프로젝트 세팅 ts 문법 기본적으로 변수, 속성, 매개변수, 리턴값에 타입이 붙었다고 생각하면 됨. const a: number = 5; function add(x: number, y: number): number { return x + y } const add: (x: number, y: number) =&gt; number = (x, y) =&gt; x +...","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_230116/",
        "teaser": null
      },{
        "title": "Today I Learned_230119",
        "excerpt":"TypeScript 인프런 타입스크립트 강의 수강 타입 추론 IDE는 tsc -noemit을 계속 돌리고 있음 타입을 추론해주는 역할을 계속한다 IDE에 손을 올렸을때 타입을 제대로 추론한다 → 제대로 쓴 것 특수한 타입 {} (null과 undefined가 아닌 모든 타입) const z: {} = 5; ts가 추론해주는 타입이 있는데 이런 건 그냥 그대로 사용하면 됨....","categories": ["TIL"],
        "tags": [],
        "url": "http://localhost:4000/til/TIL_230119/",
        "teaser": null
      }]
